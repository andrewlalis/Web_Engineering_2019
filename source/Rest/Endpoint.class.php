<?php

namespace Rest;

use Rest\AndypointTypes\DeleteRequest;
use Rest\AndypointTypes\GetRequest;
use Rest\AndypointTypes\MandatoryParameterRequest;
use Rest\AndypointTypes\PatchRequest;
use Rest\AndypointTypes\PostRequest;
use Rest\AndypointTypes\RequestType;
use SQLite3;
use SQLite3Result;

/**
 * Represents an endpoint for the API, or where a request and its parameters are processed.
 */
abstract class Endpoint
{
    /** @var string */
    private $uri;

    /** @var SQLite3 */
    private $db;

    /**
     * @var string $raw_uri The raw URI which has been requested by a client. This is updated each time the endpoint
     * is invoked.
     */
    private $raw_uri;

    /**
     * Constructs a new endpoint at the given uri.
     * @param string $uri The uri that this endpoint exists at. The URI must be formatted as follows:
     * /collection_name/{id}
     * /collection_name
     * /collection_name/{id}/child_item
     * /collection_name/{id}/child_items_collection/{child_id}
     *  - Note that path variables are identified by ASCII characters.
     */
    public function __construct(string $uri)
    {
        $this->uri = $uri;
        $this->db = new SQLite3(DB_NAME);
    }

    /**
     * Gets this endpoint's response to a request.
     * @param int $request_type The type of request (GET, POST, etc.)
     * @param array $uri_parameters An array of parameters as prescribed by this endpoint's uri.
     * @param string $raw_uri The raw URI that the client requested, with query parameters.
     * @return Response A response object, ready to be sent back to the client.
     */
    public function getResponse(int $request_type, array $uri_parameters, string $raw_uri): Response
    {
        $this->raw_uri = $raw_uri;

        $response = null; // To be generated by one of the request types, if implemented.

        $request_data = []; // Will contain request data in case the method is not GET or POST.
        parse_str(file_get_contents('php://input'), $request_data);

        if (
            $request_type === RequestType::GET
            && $this instanceof GetRequest
        ) {
            $response = $this->get($uri_parameters, $_GET);
        } else if (
            $request_type === RequestType::POST
            && $this instanceof PostRequest
        ) {
            $mandatory_error = $this->getMandatoryParameterErrorResponse($_POST);
            $response = $mandatory_error ?? $this->post($uri_parameters, $_POST);
        } else if (
            $request_type === RequestType::PATCH
            && $this instanceof PatchRequest
        ) {
            $mandatory_error = $this->getMandatoryParameterErrorResponse($request_data);
            $response = $mandatory_error ?? $this->patch($uri_parameters, $request_data);
        } else if (
            $request_type === RequestType::DELETE
            && $this instanceof DeleteRequest
        ) {
            $mandatory_error = $this->getMandatoryParameterErrorResponse($request_data);
            $response = $mandatory_error ?? $this->delete($uri_parameters, $request_data);
        } else {
            return new ErrorResponse(
                400,
                'Unsupported request method.',
                [
                    'attempted_method' => $request_type
                ]
            );
        }

        // Add the 'self' link if none is given yet.
        $links = $response->getLinks();
        if (!key_exists('self', $links)) {
            $links['self'] = $raw_uri;
        }

        return new Response(
            $response->getCode(),
            $response->getPayload(),
            $links
        );
    }

    /**
     * @return string
     */
    public function getUri(): string
    {
        return $this->uri;
    }

    /**
     * @return SQLite3
     */
    protected function getDb(): SQLite3
    {
        return $this->db;
    }

    /**
     * @return string
     */
    protected function getRawURI(): string
    {
        return $this->raw_uri;
    }

    /**
     * Gets the error response for if this endpoint does not have all mandatory parameters, or returns null if no error
     * was generated.
     *
     * @param array $request_data The request data sent by the client.
     *
     * @return ErrorResponse|null
     */
    private function getMandatoryParameterErrorResponse(array $request_data)
    {
        if (!$this->hasMandatoryParameters($request_data)) {
            if ($this instanceof MandatoryParameterRequest) {
                $mandatory_parameters = $this->getMandatoryParameters();
            } else {
                $mandatory_parameters = [];
            }
            return new ErrorResponse(
                400,
                'Not all mandatory parameters for this endpoint were provided.',
                [
                    'mandatory_parameters' => $mandatory_parameters,
                    'provided_parameters' => $request_data
                ]
            );
        }
        return null;
    }

    /**
     * Determines if this endpoint has all the mandatory parameters needed to fulfill a request.
     *
     * @param array $parameters Any request parameters provided by the client.
     *
     * @return bool True if the parameters passed to this endpoint satisfy the mandatory parameters, or false otherwise.
     */
    private function hasMandatoryParameters(array $parameters): bool
    {
        if ($this instanceof MandatoryParameterRequest) {
            return array_reduce($this->getMandatoryParameters(), function(bool $carry, string $parameter_key) use ($parameters): bool {
                return $carry && (array_key_exists($parameter_key, $parameters) && !empty($parameters[$parameter_key]));
            }, true);
        } else {
            return true;
        }
    }

    /**
     * Fetches a collection of objects using the given query.
     * @param string $query The SQL query which should result in a list of objects.
     * @param array $parameters Any parameters (and their values) which should be used with the query.
     * @return array The resulting data.
     */
    protected function fetchCollection(string $query, array $parameters = []): array
    {
        $stmt = $this->db->prepare($query);
        foreach ($parameters as $key => $value) {
            $stmt->bindValue($key, $value);
        }
        $result = $stmt->execute();
        $data = [];
        while ($row = $result->fetchArray(SQLITE3_ASSOC)) {
            $data[] = $row;
        }
        return $data;
    }

    /**
     * Inserts a new object into a table, and returns whether the operation was successful.
     *
     * @param string $table_name The name of the table into which data should be inserted.
     * @param array $column_expressions A string-indexed array of column expressions. That means that each key
     * represents the name of a column in the table, and the corresponding value is simply the expression for that
     * column, whether it be just a simple placeholder, or a nested query.
     * @param array $placeholders A string-indexed array of all the placeholders which appear in any column expressions,
     * and their corresponding values.
     *
     * @return bool True if the insert was successful, or false if an error occurred.
     */
    protected function insertIntoCollection(string $table_name, array $column_expressions, array $placeholders): bool
    {
        $sql = "INSERT INTO " . $table_name . " (" . implode(',', array_keys($column_expressions)) . ") VALUES (" . implode(',', array_values($column_expressions)) . ")";
        $stmt = $this->getDb()->prepare($sql);
        foreach ($placeholders as $name => $value) {
            $stmt->bindValue($name, $value);
        }
        $result = $stmt->execute();

        return $result !== false;
    }


}